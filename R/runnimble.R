# WARNING - Generated by {fusen} from dev/flat_nimble.Rmd: do not edit by hand

#' Run nimble
#' 
#' This function can be used to speed up the number of lines to write to run a classical `nimble` model.
#'
#' @param model \code{a nimble model}
#' @param const \code{list} of constants
#' @param data_nim \code{list} of data
#' @param inits_nim \code{list} of initial values
#' @param param \code{vector of characters} names of parameters to return
#' @param seed \code{numeric} for reproducibility
#' @param model_type \code{vector of characters} 'Fus', 'Cat' or 'dsm'. see details
#' @param narandom {vector of characters} of the parameters that should not include an individual random effect
#' @param run \code{list} Bayesian parameters used for `nimble`. They should be increased to reach convergence \itemize{
#' \item \code{nch} number of chains. Default = 1
#' \item \code{nthin} interval between iterations to keep. Default = 1 
#' \item \code{nburnin} number of iterations to discard. Default = 10 
#' \item \code{nit} total number of iterations. Default = 50 
#' }
#' @param enableWAIC \code{logical} whether the wAIC should be computed
#' @param x \code{one value} index of the model. Internal use to create tempdirectory and avoid deleting other 
#'
#' @return \code{list}
#' \itemize{\item \code{coef} matrix gathering coefficient values. The number of rows is the number of chains times the number of iterations saved
#'          \item \code{convergence} numeric vector- Rhat values
#'          \item \code{WAIC} as estimated by nimble functions}
#' 
#' @import nimble assertthat
#' 
#' @examples
#' model = glue::glue("
#'                    for(i in 1:2){{b[i] ~ dnorm(0,0.01)}}
#'                    sigma_y ~ dunif(0,10)
#'                    for(i in 1:N){{
#'                       Y[i] ~ dnorm(b[1] + b[2]*X[i] , sd = sigma_y)}}
#'                    ")
#' X = sample(c(1:10), 10, replace = TRUE)
#'
#' \dontrun{
#'outnim <- runnimble(parse(text = model),
#'                    const = list(N=10),
#'                    data_nim = list(X = X, Y = 0.1 - 4 *X),
#'                    distri='hn',
#'                    inits_nim = list(b=rep(0,2), sigma_y = 1),
#'                    param = c('b', "sigma_y"))
#'}
#'
#' @noRd
#'
runnimble <- function(model,
                      const,
                      data_nim,
                      inits_nim,
                      param,
                      seed = 0,
                      model_type = "",
                      run = list(nthin = 1,
                                 nburnin = 10,
                                 niter = 50,
                                 nch = 1),
                      enableWAIC = TRUE,
                      x = 0
                      
) {
  ## This block is necessary because nimble keeps some big temporary files that saturate memory
  ## needs to be changed when nimble will have solved these issues
  B <- paste0(tempdir(check = TRUE), '\\tempesw',x)
  dir.create(B)
  saveRDS(list(model_nim = model, 
               const_nim = const, 
               data_nim = data_nim, 
               inits_nim = inits_nim,
                run = run,
               parameters = param,
               model_type = model_type), 
          file = paste0(B,"\\arg.rds"))
  le_chemin_script <- system.file("nimblescript.R", package = "Growth")
  system2("Rscript", paste0(le_chemin_script," ",B,"\\arg.rds"), stdout = T,
          stderr = T,  invisible = F)
  chain_output <- readRDS(normalizePath(paste0(B,"\\arg.rds")))
  unlink(B, recursive = TRUE)
  ####
  
  mval=(run$nit-run$nburnin)/run$nthin
  if(run$nch ==1){
    temp <-chain_output$samples
    chain_output$samples<-list()
    chain_output$samples[[1]] <- temp
  }
  rb=array(NA,dim=c(mval,run$nch,ncol(chain_output$samples[[1]])))
  rb2 <- array(NA, dim=c(mval*run$nch,ncol(chain_output$samples[[1]])))
  for (i in 1:run$nch) {
    rb[,i,]=chain_output$samples[[i]]
    rb2[(1:mval)+mval*(i-1),]=chain_output$samples[[i]]
  }
  colnames(rb2)<-colnames(chain_output$samples[[1]])
  
  if(run$nch >1){
    conv=Rhatfun(rb,run$nch,mval,dim(rb)[3])
  }else{conv = NULL}
  
  return(list(coef = rb2, 
              convergence = conv,
              WAIC = chain_output$WAIC)
  )
}
