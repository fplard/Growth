# WARNING - Generated by {fusen} from dev/flat_nimble.Rmd: do not edit by hand

#' Estimate Rhat values
#' 
#' Derived Rubin Gelman convergence statistics from output chains of a Bayesian model
#' 
#' @param rb \code{array of dimension 3} estimates of output chains of a bayesian model. The rows should be the iterations, the column the different chains and the 3rd dimension the parameters
#' @param nch \code{numeric} number of chains
#' @param it \code{numeric} number of iterations
#' @param nparam \code{numeric} number of parameters
#'
#' @return \code{numeric vector} of size \code{nparam} giving Rhat statistics for each parameter
#' @import assertthat
#' @importFrom stats var cov median 
#'  
#' @export
#' @examples
#' rb = array(rnorm(15*3*4), dim = c(15,3,4))
#' Rhatfun(rb, nch = 3, it = 15, nparam = 4)
#'
Rhatfun<-function(rb,nch,it,nparam){
  
  assert_that(is.numeric(nch))
  if(nch==1){stop("Need more than 1 chain to estimate Rhat")}
  
  assert_that(is.numeric(it))
  assert_that(is.numeric(nparam))
  assert_that(is.array(rb))
  
  if(length(dim(rb))!=3){stop("rb should be of dimension 3")}
  if(dim(rb)[1]!=it){stop("Dimension 1 of rb should be iterations")}
  if(dim(rb)[3]!=nparam){stop("Dimension 3 of rb should be parameters")}
  if(dim(rb)[2]!=nch){stop("Dimension 2 of rb should be chains")}
  
  vari=apply(rb,c(2,3),var)
  mea=apply(rb,c(2,3),mean)
  meag=apply(rb,3,mean)
  
  W=apply(vari,2,mean)
  W1=apply(vari,2,var)
  B=apply(mea,2,var)
  cov1=cov2=rep(0,nparam)
  for (i in 1:nparam){
    cov1[i]=cov(vari[,i],y=(mea^2)[,i])
    cov2[i]=cov(vari[,i],y=mea[,i])
  }
  sig2=((it-1)/it)*W+B
  V=sqrt(sig2+B/3)^2
  varV=((it-1)/it)^2/3*W1+(4/3)^2*B^2+2*(it-1)*4/(9*it)*(cov1-2*meag*cov2)
  df=2*V^2/varV
  Rhat=abs((V/W*df)/(df-2))
  
  return(Rhat)
}

#' Summary statistics
#' 
#' Makes a summary table with main statistics for each parameter from output chains of a Bayesian model
#' 
#' @param rb2 \code{array} of dimension 3 or 2 including estimates of output chains of a bayesian model. If of dimension 3, the rows should be the iterations, the columns the different chains and the 3rd dimension the parameters. If of dimension 2, the rows should be the iterations and chains, and the columns the parameters.
#' @param nch \code{numeric} number of chains
#'
#' @return A summary matrix with columns giving mean, sd, credible interval at 2.5% and 97.5%, and Rubin Gelman Rhat statistic. The different parameters are on lines. 
#' 
#' @import assertthat
#' @importFrom stats sd quantile median 
#' 
#' @export
#' @examples
#' rb = array(rnorm(15*3*4), dim = c(15,3,4))
#' sum_nim(rb, nch = 3)
#'
sum_nim<-function(rb2, nch){
  
  assert_that(is.numeric(nch))
  assert_that(is.array(rb2))
  
  if(length(dim(rb2))!=3 & length(dim(rb2))!=2){stop("rb2 should be of dimension 3 or 2")}
  
  if(length(dim(rb2))==2){
    rb =rb2
    m=dim(rb)[1]/nch
    rb2 = array(NA, dim = c(m, nch, dim(rb)[2]))
    for (i in 1:nch){rb2[,i,] = rb[(i-1)*m+(1:m),]}
    dimnames(rb2)[[3]] = colnames(rb)
  }   
  m=dim(rb2)[1]
  assert_that(nch == dim(rb2)[2])
  long=dim(rb2)[3]
  sumres=matrix(NA,nrow=dim(rb2)[3],ncol=5)
  rownames(sumres)=dimnames(rb2)[[3]]
  colnames(sumres)=c('mean','sd','QI 2.5','QI 97.5','Rhat')
  sumres[,1]=   apply(rb2,3, mean)
  sumres[,2]=   apply(rb2,3, sd)
  sumres[,3]=   apply(rb2,3, quantile,0.025)
  sumres[,4]=   apply(rb2,3,quantile,0.975)
  if(nch> 1) {
    sumres[,5]=   Rhatfun(rb2,nch,m,long)}
  
  
  return(as.data.frame(sumres))
}

