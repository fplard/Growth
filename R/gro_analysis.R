# WARNING - Generated by {fusen} from dev/flat_main.Rmd: do not edit by hand


#' Growth model selection
#' 
#' This function fit a series of growth models to a dataset and select the best one by wAIC.
#' 
#' @param data_weight \code{data.frame} including at least the numeric columns *Age*, *MeasurementValue* and *AnimalAnonID* 
#' @param all_mods \code{vector of character} indicating the growth models that need to be fit.The following models are supported :logistic, gompertz, tpgm, power, richards, vonbertalanffy , and fabens. default = "vonBertalanffy"
#' @param random {list} of the model names giving the parameters that should include an individual random effect. See the example
#' @param run \code{list} Bayesian parameters. They should be increased to reach convergence \itemize{
#' \item \code{nch} number of chains.
#' \item \code{nthin} interval between iterations to keep.
#' \item \code{nburnin} number of iterations to discard.
#' \item \code{nit} total number of iterations.}
#' @param parallel \code{logical} Whether the model should be run in parallel
#' 
#' @import dplyr assertthat
#' @importFrom parallel detectCores parLapply makeCluster stopCluster
#' 
#' @return a list including:
#' * model: the fit of the best model
#' * the wAIC table of the model
#' 
#' @export
#' @examples
#' Age <- sample(c(0:10), 1000, replace = TRUE)
#' MeasurementValue <- exp(0.2+15 * (1 - exp(-(0.1) * log(Age+1)))+ rnorm(1000,0,0.01))-1 
#' AnimalAnonID <- sample(c(0:20), 100, replace = TRUE)
#' dat = data.frame(Age = Age, MeasurementValue = MeasurementValue, 
#'                  AnimalAnonID = AnimalAnonID, MeasurementType = "Live Weight")
#'
#' #Test 4 models: vonbertalanffy including an individual random effect on z0
#' #               vonbertalanffy including individual random effects on z0 and zinf
#' #               fabens including an individual random effect on gamma 
#' #               fabens including no individual random effect
#' a = Gro_analysis(dat, all_mods  = c("vonbertalanffy", "fabens"),
#'                  random = list(vonbertalanffy = c("z0", "z0, zinf"), fabens = c("gamma", "")),
#'                  run = list(nit = 1000, nburnin = 100, nthin = 1, nch = 1))
Gro_analysis <- function(data_weight, 
                         all_mods =c("vonbertalanffy"),
                         random = list(),
                         run = list(nit = 100, nburnin = 10, nthin = 1, nch = 1),
                         parallel= FALSE
) {
  assert_that(is.logical(parallel))
  assert_that(all(all_mods %in% c("logistic", "gompertz", "richards", "vonbertalanffy", "fabens", "tpgm", "power", "richard")), msg = "The growth models supported are: logistic, gompertz, tpgm, power, richards, vonbertalanffy, and fabens")
  assert_that(is.data.frame(data_weight))
  assert_that(data_weight %has_name% c("MeasurementValue","Age", 'AnimalAnonID'))
  assert_that(all(data_weight$Age >= 0 ))
  assert_that(all(data_weight$MeasurementValue > 0 ))
  if(length(random)>1){
    assert_that(is.list(random))
    assert_that(all(names(random) %in% all_mods))
  }
  
  
  data_weight<-data_weight%>%
    mutate(logx = log(Age + 1),
           logz = log(MeasurementValue + 1),
           IND = as.numeric(factor(AnimalAnonID, labels = c(1:length(unique(AnimalAnonID))))))
  
  #Fitting the different growth models
  all_fits_tab=c()
  all_fits <- list()
  
  models = rep(names(random),as.vector(sapply(random, length)))
  miss = setdiff(all_mods,names(random))
  models = c(models, miss)
  randoms = c(unlist(random), rep('',length(miss)))
  #Fit models
    ### parallelize?
  if (parallel){
    n_cores <- detectCores()
    clust <- makeCluster(n_cores)
  }
  if(parallel) {
    all_fits <- parLapply(clust, 1:length(models),
                          Gro_run,
                          all_mods = models,
                          random = randoms,
                          dat = data_weight,
                          run = run
    )
    
  }  else {
    writeLines("\t* parallel has been set to FALSE, please wait more !")
    all_fits <- pbapply::pblapply(1:length(models),
                                  Gro_run,
                                  all_mods = models,
                                  random = randoms,
                                  dat = data_weight,
                                  run = run
    )
  }
  
  all_fits_tab=c()
  for (i in 1:length(all_fits)){
    all_fits_tab <- rbind(all_fits_tab,all_fits[[i]]$tab)
  }
  all_fits_tab <- all_fits_tab%>% arrange(WAIC)
  best_std <- all_fits[[as.numeric(all_fits_tab[1, "index"]) ]]$model
  if(parallel) {
    stopCluster(clust)
  }
  
  
  all_fits_tab <- all_fits_tab%>% 
    dplyr::select(-index)
  
  return(list(model = best_std,
              wAIC_tab =all_fits_tab)
  )
}
